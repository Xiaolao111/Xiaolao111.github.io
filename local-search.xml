<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对阶次分析的一些理解</title>
    <link href="/2024/08/30/understanding-of-order-analysis/"/>
    <url>/2024/08/30/understanding-of-order-analysis/</url>
    
    <content type="html"><![CDATA[<p>本文是我在项目过程中，对振动加速度数据的阶次分析的一些理解</p><h1 id="频谱分析">频谱分析</h1><h2 id="原理">原理</h2><p>在不考虑数据滤波的情况下，频谱分析为时域数据作FFT的结果，其中纵轴为振动幅度（常见单位有g，mm/s<sup>2</sup>等），横轴为频率，其中，能够采集到的最大频率为F<sub>max</sub>，频谱分辨率为F<sub>n</sub>，采样率为F<sub>s</sub>，采样点数为N<span class="math display">\[F_{max}=\frac{Fs}{2},     F_n=\frac{Fs}{N}\]</span> 示例： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Fs = <span class="hljs-number">1024</span><br>Fb = <span class="hljs-number">10</span><br>x = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>)<br>t = x / Fb<br>data_len = <span class="hljs-number">1024</span><br>y = np.sin(<span class="hljs-number">2</span> * np.pi * x / Fs * Fb)<br>fft_y = np.fft.fft(y)<br>fft_y = (np.abs(fft_y) / data_len)[range(<span class="hljs-type">int</span>(data_len / <span class="hljs-number">2</span>))] * <span class="hljs-number">2</span><br>fft_y[<span class="hljs-number">0</span>] = fft_y[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span><br>fig, ax = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>line_0 = ax[<span class="hljs-number">0</span>].plot(t, y)<br>ax[<span class="hljs-number">0</span>].set_xlabel(<span class="hljs-string">&#x27;time [s]&#x27;</span>)<br>line_1 = ax[<span class="hljs-number">1</span>].plot(fft_y)<br>ax[<span class="hljs-number">1</span>].set_xlabel(<span class="hljs-string">&#x27;Frequency [Hz]&#x27;</span>)<br><br>mplcursors.<span class="hljs-keyword">cursor</span>(line_0, hover=<span class="hljs-keyword">False</span>, multiple=<span class="hljs-keyword">True</span>).<span class="hljs-keyword">connect</span>(&quot;add&quot;, lambda sel: sel.annotation.set_text(<br>    f&quot;x=&#123;sel.target[0]:.2f&#125;, y=&#123;sel.target[1]:.2f&#125;&quot;))<br>mplcursors.<span class="hljs-keyword">cursor</span>(line_1, hover=<span class="hljs-keyword">False</span>, multiple=<span class="hljs-keyword">True</span>).<span class="hljs-keyword">connect</span>(&quot;add&quot;, lambda sel: sel.annotation.set_text(<br>    f&quot;x=&#123;sel.target[0]:.2f&#125;, y=&#123;sel.target[1]:.2f&#125;&quot;))<br>plt.<span class="hljs-keyword">show</span>()<br></code></pre></td></tr></table></figure> <img src="\img\blog_order\Figure_1.png"alt="FFT演示" /></p><h1 id="阶次分析">阶次分析</h1><p>阶次分析和频谱分析有完全不同的应用场景，阶次分析的好处是，一个转动系统，转速往往一直在变化，如果做频谱分析，我们会发现频谱会随转速变化，但是阶次分析与转速无关。频率分析适合系统中有固定频率存在的情况，而阶次分析适合系统中各部件互相耦合，转速一致变化的情况</p><h2 id="基于时域采样的阶次分析">基于时域采样的阶次分析</h2><p>假设基准频率固定为<em>F</em>Hz，转速为<em>S</em>rpm，易得： <spanclass="math display">\[F=\frac{S}{60}\]</span> 传统的频谱分析也是基于时域采样，所以，频谱到阶次谱只需要：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#  fft_y不变</span><br><span class="hljs-attr">fft_x</span> = fft_x / F<br></code></pre></td></tr></table></figure> 这样，能够采集到的最大阶次为 <span class="math display">\[order_{max} =\frac{ F_{s}}{2* F}\]</span> 阶次分辨率为 <span class="math display">\[order_{n} =\frac{Fs}{N*F}\]</span>假设我们在对一个传动系统的振动做阶次分析，以输入轴转速为基准转速，转速大约在300rpm到1500rpm，传感器的采集频率为5.12kHz，采集时间为0.5s，那么，在300rpm时，我们能计算的阶次范围为0-5120阶，分辨率为0.6阶，在1500rpm时，阶次范围为0-1024阶，分辨率为0.08阶可以看出，当转速变化时，最大阶次和分辨率也会跟着变化，这样其实不利于分析和比较，而且时域采样的一个重要缺点是，无法处理频率随时间变化的非平稳信号，否则会有严重的拖尾效应，所以更多的阶次分析，会采用角度域采样而非时域采样</p><p>非平稳信号的拖尾效应示例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">Fb = <span class="hljs-number">10</span><br>x = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>)<br>t = x / Fb<br>data_len = <span class="hljs-number">1024</span><br>order_x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-built_in">int</span>(data_len / <span class="hljs-number">2</span> / Fb), <span class="hljs-built_in">int</span>(data_len / <span class="hljs-number">2</span>))<br>instantaneous_frequency = Fb + np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, data_len )<br>y = np.sin(<span class="hljs-number">2</span> * np.pi * np.cumsum(instantaneous_frequency) / <span class="hljs-built_in">len</span>(t))<br>fft_y = np.fft.fft(y)<br>fft_y = (np.<span class="hljs-built_in">abs</span>(fft_y) / data_len)[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(data_len / <span class="hljs-number">2</span>))] * <span class="hljs-number">2</span><br>fft_y[<span class="hljs-number">0</span>] = fft_y[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span><br>fig, ax = plt.subplots(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>line_0 = ax[<span class="hljs-number">0</span>].plot(t, y)<br>ax[<span class="hljs-number">0</span>].set_xlabel(<span class="hljs-string">&#x27;Time [s]&#x27;</span>)<br>line_1 = ax[<span class="hljs-number">1</span>].plot(fft_y)<br>ax[<span class="hljs-number">1</span>].set_xlabel(<span class="hljs-string">&#x27;Frequency [Hz]&#x27;</span>)<br>line_2 = ax[<span class="hljs-number">2</span>].plot(order_x, fft_y)<br>ax[<span class="hljs-number">2</span>].set_xlabel(<span class="hljs-string">&#x27;Order&#x27;</span>)<br>mplcursors.cursor(line_0, hover=<span class="hljs-literal">False</span>, multiple=<span class="hljs-literal">True</span>).connect(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-keyword">lambda</span> sel: sel.annotation.set_text(<br>    <span class="hljs-string">f&quot;x=<span class="hljs-subst">&#123;sel.target[<span class="hljs-number">0</span>]:<span class="hljs-number">.2</span>f&#125;</span>, y=<span class="hljs-subst">&#123;sel.target[<span class="hljs-number">1</span>]:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>))<br>mplcursors.cursor(line_1, hover=<span class="hljs-literal">False</span>, multiple=<span class="hljs-literal">True</span>).connect(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-keyword">lambda</span> sel: sel.annotation.set_text(<br>    <span class="hljs-string">f&quot;x=<span class="hljs-subst">&#123;sel.target[<span class="hljs-number">0</span>]:<span class="hljs-number">.2</span>f&#125;</span>, y=<span class="hljs-subst">&#123;sel.target[<span class="hljs-number">1</span>]:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>))<br>mplcursors.cursor(line_2, hover=<span class="hljs-literal">False</span>, multiple=<span class="hljs-literal">True</span>).connect(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-keyword">lambda</span> sel: sel.annotation.set_text(<br>    <span class="hljs-string">f&quot;x=<span class="hljs-subst">&#123;sel.target[<span class="hljs-number">0</span>]:<span class="hljs-number">.2</span>f&#125;</span>, y=<span class="hljs-subst">&#123;sel.target[<span class="hljs-number">1</span>]:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>))<br>plt.show()<br></code></pre></td></tr></table></figure> <imgsrc="\img\blog_order\Figure_2.png" alt="非平稳信号的分析示例" /></p><h2 id="基于角度域采样的阶次分析">基于角度域采样的阶次分析</h2><p>角度域采样的原理是，选择旋转部件，该部件旋转一周，等间隔采样N个点，此时N为角度域采样的采样频率，对角度域信号做FFT，可得到基于旋转部件转速的阶次谱</p><h3 id="采样时间内转速无变化">采样时间内转速无变化</h3><p>假设旋转部件的转动频率为F不变，转过一圈采样N个点，每采N×n做一次FFT，由于转速不变，可知时域采样率为F*N，FFT后的频谱，点数为N×n/2，最大频率为F*N/2，我们把频谱的横轴除以旋转部件的频率，得到阶次谱，阶次谱的最大阶次为Order<sub>max</sub>，谱线分辨率为Order<sub>n</sub>，可知：<span class="math display">\[order_{max} =\frac{ N}{2}\]</span> <span class="math display">\[order_{n} =\frac{order_{max} }{\frac{N×n}{2}}  =\frac{1}{n}\]</span>可以看到，相比于时域采样，角度域采样之后的阶次谱，最大阶次和阶次分辨率都与转速无关了，我们可以通过增大采样率N来扩大阶次谱范围，通过增大采样次数n来减小分辨率，提升精度<img src="\img\blog_order\Figure_3.png" alt="角度域采样举例" /></p><h3 id="采样时间内转速变化">采样时间内转速变化</h3><p>我的理解：阶次分析时需要把FFT后的频率轴转为阶次轴，也就是除以转频F，那么这里转频需要是一个固定的量，目前看到的处理方法基本为求采样时间内转速的平均值，作为该段时间的转速。如果在采样时间内转速变化很大，那么会导致求取阶次时误差也比较大</p><p>对于角度域采样，有<em>硬件</em>和<em>软件</em>两种处理方式，硬件处理是每转过恒定角度时触发采样，得到的原始数据就是角度域数据（但是不知道这种方法是否方便切换采样率）；软件处理指先采集时域信号，上位机端结合转速信号对时域信号进行基于角度域的重采样，这种做法好处是采样率很好控制，坏处是软件端的工作量会比较大</p>]]></content>
    
    
    
    <tags>
      
      <tag>FFT</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/08/21/hello-world/"/>
    <url>/2024/08/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
